---
icon: discover
date: 2023-01-06
title: 碰碰球
tag:
  - 记录
---

>我在github上翻到了小时候喜欢玩的一个游戏的一部分代码\
……感觉有些，不知道怎么说的感觉。那个游戏在我初中的时候停更，高中的时候关服...\
它所依赖的技术也都过时了\
一门半死不活的语言ActionScript，还有一个被现在大多数浏览器抛弃的平台Adobe Flash\
十年前…\
那时候我还能一玩一整天…\
可是直到它关服我甚至都还不会按F12，也许早点知道的话能看到更多...

所以为什么是碰碰球？因为它简单啊...其实有想过贪吃蛇...但感觉有点麻烦，玩家之间交互麻烦...。主要大概也不是canvas...而是，我想做成一个在浏览器里能玩的，在线的，简单的多人游戏。

要依赖后端去做一个同步。要不要搞“房间”？进入的时候弄个名字选个颜色调调自己球的大小？另一方面，动作更新也是在前端做发给后端，这样才能转发到其他的前端...？传输的时候是不是还要带个token来确认谁是谁...后端到底要存多少东西？...完全没想好。

技术方面，游戏的网络通信，...战网？游戏竟然也有P2P...？

即时的动作、对战类游戏都有它们特化的网络方案，但我不想看...我现在甚至想从“websocket聊天室”这种东西上魔改出一个东西。spring貌似也能做...还有更对口点的socket-io...
但是前端大概...完全和那些框架没关系，顶多两个页面，朝服务器发发请求和数据...

---

嗯...，难搞，那就，哪怕先做成个单人的demo，先想想前端部分。

基本的有，碰撞时改变速度的效果，移动时随时间的加速度，速度上限，加速度固定，边界框框也是个挺重要的东西，是做成相互连接的“瞬移”，还是碰撞体，还是游戏结束的区域，或者交给玩家去选....。球球要有重量吗？这样搞了就要有力，让力成为平衡点..，先不要...。要有大小吗？这只与容易或不容易发生碰撞有关...也许可以加上，反正不难。这些，场地和球球的属性嗯，名字就起Playground和Ball，这部分应该是主要部分\
还有控制输入的方式，键盘，选键位，还有跟随鼠标，再或页面上添一个拖拽的方向盘，直接控制的是加速度，或者说力...还有一个，关于键盘键位，如果是两侧对称的物体，那会有前后控制速度，左右控制方向这样...但是我们是球球，四个键全部搞成速度方向耦合算了，按压着就是有那个方向的加速度，两个不矛盾的同时去按就是给个间位方向，反方向同时按着的话就记成0\
再一个就是，在之后碰撞检测这种事情可能得交给后端或者说服务端..因为要在多端同步。一个挺重要的问题————最少交多少数据可以实现这一部分功能？

碰撞...碰撞的一瞬间发生的应该是速度的变化，包括方向和大小。检测碰撞依赖的是位置。而，想要计算出碰撞之后的变化情况，需要的是碰撞前的速度————方向+大小，也许可以加个重量这个属性但这个先不考虑。

那好吧...我的一个想法就是，平时只发位置，而在检测到碰撞之后，去向前端请求速度信息。————完全没必要，计算还是要全放后端。————只能...一边学不懂的东西一遍处理这些..了吗。用nodejs的后端吧。至少能同一门语言。

算了先做个前端版的。也是为什么我会把这个文章放在这里的原因...吧。

好，整理一下。

- 物理模型，场地和球球
  - Playground
    - 力、加速度
    - 速度上限 & 摩擦力
    - 碰撞检测 & 结果计算
    - 边界
  - Ball
    - 大小
    - 质量
    - 位置
    - 速度

- 输入模式
  - 上下左右
  - 鼠标引导
  - 鼠标，还有移动端的，拖拽的方向盘

先，全在，前端写。突然感觉高中学的物理有点用了..嘿。

对了...我看了的仓库好多都是接近十年前的...原来，真的有好多好多用 IIFE 做模块化的啊...好艰苦...

### 2023-01-07

H5小游戏...的一些游戏引擎。md现在怎么是个游戏就要搞3d那一套...2d就不好玩了吗!?...3d可能是沉浸感...2d还要人..

[Pixi.js](https://github.com/pixijs/pixijs)

[Phaser](https://github.com/photonstorm/phaser)

[CreateJS](https://github.com/createjs)

几年前的好多小仓库...自己写向量对象，自己建物理模型...

如果要找工作也许这不是一个合适的方向...但是好想看...

然后是这个仓库

**[bouncing-balls](https://mtrajk.github.io/bouncing-balls)**

嗯，分析代码。

- 有一个自己实现的向量处理工具，以对象方式呈现-Vector2D
- 然后是ball这个文件里做了Ball这个对象，包括移动、碰撞等物理模型
  - 中学物理.jpg
- 再然后是 bouncing-balls 这个文件里，绑定canvas，动画，事件，添加交互接口...
  - 值得一提的是，这里也有一个，“虚拟画布”的概念。就是，处理物理模型有一个固定的画布大小————宽度单位为 100,长宽比为3:2，就是说，在后台处理运动与碰撞这些事件的时候，处理的数据都是固定的，而渲染出的大小会根据css样式给出的盒子大小进行自动放缩
    - 这很重要，从单机小游戏的各个屏幕适配，到做成前后端分离的多人在线中后台数据的统一处理，这都帮了大忙
    - 这个操作我不是第一次见到...之前在做瀑布流处理那些长方形的时候也有类似操作
    - 但我不确定应该把哪一个叫做虚拟哪一个叫做真实，因为后台处理可以看作一种真实，因为这边决定了各个事件的触发；前端渲染也可以看作一种真实，因为它是实实在在渲染出的效果。
      - 懂了，后台的叫做本质，前台的叫做存在。

这个结构其实和我想的不太一样...

>说起来有点离谱..但我感觉这个游戏(apex)，还有吃鸡，有好多地方和一些小游戏其实很像？\
就比如捡装备像是吃食物，射击游戏里会有各种各样的体现，而贪吃蛇里是自己蛇的身体变长。\
还有个元素是“缩圈”，我就想到了碰碰球那个游戏，把别人从台子上挤下去......

### 2023-01-08

又...因为些无聊事困惑。我想了想，[我都想要](../../../../learn-dialectic/kunhuo/good-feeling.md/#2023-01-08)，对，我都想要，自己学东西做东西，还有，找工作的机会，还有...，我寻思我能行。

就，今天就留给，梳理一些 JavaScript 的东西。主要两个方面，面向对象，还有一个模块化。

#### 面向对象 && 构造函数 && 原型 && 原型链

好久之前学校教java的时候...老师似乎着重提了一下构造函数这一块东西，但当时我真是...不知道在干啥，迷迷糊糊。而我现在看JavaScript 实现面向对象的方式...————从某种意义上讲，定义构造函数即是定义类。这一点我在看用 canvas 做小东西的这两个仓库真是太明显了。。

好了下面我试着整理的清晰一些。

面向对象中最重要的要素无疑就是对象，关于对象，我会想到Hash，Map，Set，这样的有更加具体功能键值对，甚至是 JSON...，键值对可以来回嵌套，其中的“键”通常是字符串，但也可以不是，它是一个标识，类似变量名的标识，而它所标识的东西，所代表的东西，那就多了，可以是另一个字符串、数字，也可以是函数(也许这里应该叫方法)，当然也可以是另一个对象。————仅仅就是键值对(变量与变量值，能指与所指的链接，不只是编程语言..也是自然语言所拥有的，甚至可以说是唯一的也是暴力的功能)，使用这种东西，加上些复杂结构，可以建造出一个十分庞大的世界...

创建对象当然可以像创建变量一样直接使用字面量去创建，缺点是什么？...手动一个个的硬写对象，好累的哦。

所以就有了，使用构造函数去创建对象。JavaScript 有许多内置的构造函数:

```js
let o = new Object();  // Create an empty object: same as {}.
let a = new Array();   // Create an empty array: same as [].
let d = new Date();    // Create a Date object representing the current time
let r = new Map();   
```

看看它们的形式————在等号/赋值式右边，一个new关键字，然后接上一个构造函数名，带括号的意思就是即时调用。然后就会在左边接收到一个被创建出的对象！

而我们自然也可以自己定义构造函数，在 JavaScript 中，甚至不需要类...直接的一个函数就可以...这也让我们意识到，至少在JavaScript中 并不存在特别去定义构造函数的方法，而是仅当使用 new 时，函数调用会变成 ‘构造函数调用’。
通常，这个函数并不会用 return 去返回什么值，而是通过 this 这个关键字将各种属性绑定到自己，或者应该说，在创建对象时，会自动绑定到将要实例化的那个对象身上。

```js
function Range(from, to) {
    // Store the start and end points (state) of this new range object.
    // These are noninherited properties that are unique to this object.
    this.from = from;
    this.to = to;
}
let range13 = new Range(1,3)
```

到这里我们的重心会放到类这一边，注意，构造函数，或者说类，它们的命名是大写的。这是种规范...
~~但 Captialh还有个意思是资本，怎么说呢，无论好坏，这都是种十分powerful的东西。啊！帕瓦！~~
相比于对象，类是更加抽象的一边，更加接近于“本质”，“造物者”的一边.。

```js
Range.prototype.includes = function(x) { 
  return this.from <= x && x <= this.to; 
}
```

JavaScript 函数对象具有 prototype 属性，而在这里，会有可以添加一系列新东西的机会。prototype 上添和 直接this 添有什么区别？
>this定义的方式，实例化之后是让每一个实例化对象都有一份属于自己的在构造函数中的对象或者函数方法，而prototype定义的方式，实例化之后每个实例化对象共同拥有一份构造函数中的对象或者函数方法。一般而言，用this来定义构造函数的属性较多，用prototype定义构造函数的方法较多。

再另外，在这个属性上，我们可以挂上一堆其他函数，而js中的继承，或者说类似继承的操作，也是利用这里，利用原型链来实现。而在两个小仓库中，用了不知道多少次这样的代码去往构造函数上添东西。

我们不想去一次次手操对象，但我们也并不会想要手操太多类，类所具有的抽象性让我们有机会去巧妙的设计类与类之间的关系进而更加清晰的去描述、实现功能。而这里，就是设计模式。面向对象的所谓三大特性，也应该算在这里。原型链，继承或组合，单例模式...算了这两个小仓库也没用到太多，先打住。

#### IIFE && ES6 modules

之前在看为了应对 var 的怪异的 hosting(突然觉得这个词很形象，变量们被“悬吊”在了代码块之外，乱七八糟的吊在了一个公共空间，可以随意的摘下来用) 特性，去用 IIFE 来获得一个私有空间，IIFE 是可以做模块化的，包括之后let const支持的闭包也是一种小型的模块化，而真正实用，并且权威官方一点的实现，该是 ES6 modules.

也许会有 CommonJS 等等在nodejs之类的社区中的实现..依赖 webpack babel 这样的打包工具来在适配浏览器，但现在既然有了标准，也有了浏览器直接支持的 ES6 modules，...为啥还要整那些呢。不看喵。

```js
<script type="module">

import
export

default，const ...
```

一个类，一个函数，一个代码块，看作一个模块。这挺自然的...完成这个类也许会依赖一些工具函数，这部分实现细节并不是想要暴露的地方，所以要专门的export。

怎么说...引用时直接加上一个type="module"，浏览器就会自动将每个文件视为一个独立的模块。似乎没什么可说的。
而在本地查看时，会因为模块化增强的同源策略，file协议会显示跨域...要搞个LiveServer才能调试。
