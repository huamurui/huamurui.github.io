import{a6 as r,F as h,G as u,D as l,M as e,ac as a,R as i,ad as s,V as o}from"./framework-913605ae.js";const c={},p=l("p",null,"嗯...软件工程.. 如果这也算一门学科的话，那这门学科就是关于失败的学科，它是从一次次软件危机中诞生出的一堆东西。 这种失败也许算种人类普遍的失败，数学也是经历了一次次危机才有了今天这样庞大又折磨人的体系。",-1),d=l("p",null,"但在一开始，它们这些“失败经验”可能并没有那么重要，重要的是失败本身，那堆语言特性与设计模式，在自己也遇到那样的失败时，自然都会想到。",-1),_=l("p",null,"对的，去动手。",-1),f=l("p",null,"vim和命令行=> python csv/excel数据库 网页=> 服务端 数据库/操作系统 客户端=>",-1),b=l("hr",null,null,-1),v=l("h2",{id:"开始",tabindex:"-1"},[l("a",{class:"header-anchor",href:"#开始","aria-hidden":"true"},"#"),i(" 开始")],-1),m=l("p",null,"回忆一下，我初来乍到的时候，看到想到的一些东西。 那时候，vue2，我发现了在这里，组件也有一个父子关系，但这个父子与 java 与传统面向对象的类的父子差别太大...parent-chid",-1),w=l("ul",null,[l("li",null,"vue 这边大组件、parent 组件是更大更全的；而 java 类的 parent 虽然是一个根基但却很空，有太多没有实现或者需要修改的，依赖之后的多态去重写。最后干活上，vue 就是那个大 parent 直接去干，而java则是需要之后的子类去干。")],-1),x=l("p",null,[i("以上是两种不同的设计思路，而因为碰巧，我找到了一个很合适的区分点，vue 那边是自底向上，而java则是自顶向下。"),l("br"),i(" java 也许能让手熟的人快速的建立起一个架构，但对于一上来没有总体意识的菜鸟..稍微有点点灾难。而在后续的更新迭代上，因为存在那样一个根基以及一层层磊摞的关系，也更容易遇到不兼容的问题。但怎么说，也许对于老手而言，它快啊。")],-1),k=l("p",null,"而再再之后，我又看到了另一种对此的区分，那就是 继承 vs 组合。就是直直的 diss 到面向对象的继承上，这种代码复用方式与当时比较贫瘠的计算机资源也有关，但不管怎样以这种方式实现的复用，代码之间的耦合度会很高。而对此，另一种复用方式被推了出来——组合。组合最简单的有上面 vue 的组件的组合，也有函数式编程里的一堆骚操作，有游戏开发那边的ECS...那面向对象怎么办呢，不救一救吗？",-1),j=l("strong",null,"“注入”",-1),g={href:"https://www.zhihu.com/question/59716738",target:"_blank",rel:"noopener noreferrer"},q=l("blockquote",null,[l("p",null,[i("Objects are poor man's closures."),l("br"),i(" &"),l("br"),i(" Closures are poor man's objects.")])],-1),L=s('<blockquote><p>确实哦...java 出了一堆依赖注入的框架，js 到了es6 也终于好好搞了模块化和闭包...</p></blockquote><p>嗯...想到了UML图里的那一堆东西......啊。。。。。这真tmd是一堆玄学。</p><p>按 UML 的分析方式，类有4种关系，1.依赖/关联/组合，2.实现(继承接口/实现对象)，3.泛化(继承)。 而前几种，相对较弱的相互关系...也会耦合的很强...吗。</p><p>局域变量、静态方法的调用，成员变量、方法形参，。</p><h2 id="uml" tabindex="-1"><a class="header-anchor" href="#uml" aria-hidden="true">#</a> UML</h2><p>三个基本模块：事务，关系，图。</p><ul><li>事务 <ul><li>结构事务：类，接口，协作，用例，活动类，组件，节点。</li><li>行为事务：交互，状态机。</li><li>分组事务：包</li><li>注释事务：注释。</li></ul></li><li>关系 <ul><li>依赖</li><li>关联</li><li>实现</li><li>泛化</li></ul></li><li>图 <ul><li>用例图</li><li>类图</li><li>对象图</li><li>包图</li><li>部署图</li><li>活动图</li><li>状态图</li><li>序列图</li><li>协作图</li><li>组件图</li></ul></li></ul><h2 id="设计模式" tabindex="-1"><a class="header-anchor" href="#设计模式" aria-hidden="true">#</a> 设计模式</h2>',8),C={href:"https://www.zhihu.com/question/308850392/answer/1324509357",target:"_blank",rel:"noopener noreferrer"},E=s('<p>也许我应该把这些搬到 java 那边...</p><p>设计模式基于六大原则：</p><ul><li>开闭原则：一个软件实体如类、模块和函数应该对修改封闭，对扩展开放。</li><li>单一职责原则：一个类只做一件事，一个类应该只有一个引起它修改的原因。</li><li>里氏替换原则：子类应该可以完全替换父类。也就是说在使用继承时，只扩展新功能，而不要破坏父类原有的功能。</li><li>依赖倒置原则：细节应该依赖于抽象，抽象不应依赖于细节。把抽象层放在程序设计的高层，并保持稳定，程序的细节变化由低层的实现层来完成。</li><li>迪米特法则：又名「最少知道原则」，一个类不应知道自己操作的类的细节，换言之，只和朋友谈话，不和朋友的朋友谈话。</li><li>接口隔离原则：客户端不应依赖它不需要的接口。如果一个接口在实现时，部分方法由于冗余被客户端空实现，则应该将接口拆分，让实现类只需依赖自己需要的接口方法。</li></ul><hr><blockquote><p>在这里，也许是对抽象的，一个最基本的使用，抽象与具体的实例、对象间的桥梁。而之后的结构(我会想称之为静态关系)，与行为模式，则是抽象与抽象之间的对舞了。</p></blockquote><ul><li><p>构建型模式，一共五种，分别是：</p><ul><li>工厂方法模式</li><li>抽象工厂模式</li><li>单例模式</li><li>建造型模式</li><li>原型模式</li></ul></li><li><p>结构型模式是用来设计程序的结构的。结构型模式就像搭积木，将不同的类结合在一起形成契合的结构。包括以下 7 种结构型模式：：</p><ul><li>适配器模式</li><li>桥接模式</li><li>组合模式</li><li>装饰模式</li><li>外观模式</li><li>享元模式</li><li>代理模式</li></ul></li><li><p>行为型模式重点关注 类与类之间的交互与协作，行为型模式共 11 种，分别是：</p><ul><li>责任链模式</li><li>命令模式</li><li>解释器模式</li><li>迭代器模式</li><li>中介者模式</li><li>备忘录模式</li><li>观察者模式</li><li>状态模式</li><li>策略模式</li><li>模板方法模式</li><li>访问者模式</li></ul></li></ul><h2 id="代码美学" tabindex="-1"><a class="header-anchor" href="#代码美学" aria-hidden="true">#</a> 代码美学</h2><h3 id="组合-vs-继承-抽象-with-耦合" tabindex="-1"><a class="header-anchor" href="#组合-vs-继承-抽象-with-耦合" aria-hidden="true">#</a> 组合 vs 继承 || 抽象 with 耦合</h3><p>组合与图，继承与树</p><h3 id="命名" tabindex="-1"><a class="header-anchor" href="#命名" aria-hidden="true">#</a> 命名</h3><p>起名字很难，并且很多时候，不在起名本身，还有，代码结构等等问题。</p><h3 id="注释" tabindex="-1"><a class="header-anchor" href="#注释" aria-hidden="true">#</a> 注释</h3><p>类型，测试，命名...这些东西都可以作为注释。</p><p>而注释...可以在更高，在更抽象的层面，来解释代码的意图。</p><h3 id="拒绝嵌套" tabindex="-1"><a class="header-anchor" href="#拒绝嵌套" aria-hidden="true">#</a> 拒绝嵌套</h3><p>嗯...但是有些地方，比如 UI 设计，还有 XML 该嵌套就嵌套。</p>',16);function M(S,V){const t=o("RouterLink"),n=o("ExternalLinkIcon");return h(),u("div",null,[p,d,_,l("p",null,[e(t,{to:"/posts/CS/front-end/practice/vue-waterfall.md/#object"},{default:a(()=>[i("面向对象")]),_:1})]),l("p",null,[e(t,{to:"/posts/CS/front-end/practice/canvas/bumping-balls.md/#2023-01-08"},{default:a(()=>[i("构造函数")]),_:1})]),f,b,v,m,w,x,k,l("p",null,[i("好了先回到 vue，组件组合这种关系的一个常见范例是，parent 组件拿到数据传给子组件的 props，然后子组件根据拿到的数据去渲染，这个传数据的过程，让我想到了"),e(t,{to:"/posts/CS/front-end/philosophy/strange-things.md/#props"},{default:a(()=>[j]),_:1}),i("...进而想到了依赖注入这个词——这是面向对象为了解耦而搞的一种操作。")]),l("blockquote",null,[l("p",null,[i("哦~这句话好炫酷... ["),l("a",g,[i("https://www.zhihu.com/question/59716738"),e(n)]),i("]")]),q]),L,l("p",null,[i("["),l("a",C,[i("https://www.zhihu.com/question/308850392/answer/1324509357"),e(n)]),i("]")]),E])}const N=r(c,[["render",M],["__file","software-engineering.html.vue"]]);export{N as default};
